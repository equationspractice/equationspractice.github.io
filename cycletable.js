[
    [ // K = 6
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [2, 3, 6, 4, 4, 7, 6, 5, 18, 5, 10],
        [1, 2, 3, 2, 4, 3, 6, 4, 4, 4, 5],
        [1, 1, 3, 3, 2, 3, 3, 3, 9, 2, 5],
        [2, 2, 6, 2, 2, 6, 6, 4, 18, 2, 10],
        [1, 3, 3, 4, 1, 3, 2, 5, 4, 3, 10],
        [1, 2, 3, 2, 4, 6, 1, 2, 9, 4, 10],
        [2, 2, 2, 2, 4, 2, 2, 3, 6, 4, 10],
        [1, 1, 1, 1, 2, 1, 3, 2, 3, 2, 5],
        [1, 3, 1, 4, 1, 3, 6, 5, 3, 3, 2],
        [2, 2, 6, 2, 2, 6, 6, 4, 18, 2, 2]
    ],
    [ // K = 7
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [3, 3, 6, 4, 12, 6, 21, 5, 6, 12, 30],
        [6, 6, 6, 6, 12, 6, 42, 6, 7, 12, 30],
        [3, 3, 3, 3, 6, 3, 21, 4, 3, 6, 15],
        [6, 6, 6, 6, 6, 6, 42, 6, 6, 6, 30],
        [2, 2, 2, 3, 2, 2, 14, 4, 3, 2, 10],
        [1, 1, 1, 2, 4, 1, 3, 2, 3, 4, 10],
        [1, 1, 2, 1, 4, 2, 7, 1, 2, 4, 10],
        [3, 3, 3, 3, 6, 3, 21, 3, 3, 6, 15],
        [6, 6, 6, 7, 6, 6, 42, 8, 6, 6, 6],
        [3, 3, 6, 6, 3, 6, 21, 6, 6, 3, 3]
    ],
    [ // K = 8
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [4, 5, 4, 6, 6, 5, 5, 7, 8, 7, 12],
        [2, 4, 2, 8, 4, 4, 6, 16, 3, 4, 10],
        [3, 3, 3, 4, 3, 3, 4, 4, 4, 3, 6],
        [2, 4, 2, 8, 2, 4, 6, 16, 6, 4, 10],
        [4, 5, 4, 6, 4, 5, 4, 7, 4, 5, 12],
        [2, 2, 2, 4, 4, 2, 2, 8, 6, 4, 10],
        [1, 3, 2, 3, 4, 3, 1, 3, 2, 5, 10],
        [1, 2, 1, 4, 2, 2, 3, 8, 1, 2, 5],
        [4, 5, 4, 6, 4, 5, 8, 7, 4, 5, 4],
        [2, 4, 2, 8, 2, 4, 6, 16, 6, 4, 2]
    ],
    [ // K = 9
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [6, 6, 18, 7, 12, 18, 6, 8, 54, 12, 30],
        [3, 3, 4, 3, 5, 4, 7, 3, 5, 5, 6],
        [3, 3, 9, 3, 6, 9, 3, 4, 27, 6, 15],
        [6, 6, 18, 6, 6, 18, 6, 6, 54, 6, 30],
        [3, 3, 4, 3, 3, 4, 3, 4, 5, 3, 11],
        [3, 3, 9, 6, 12, 9, 3, 6, 27, 12, 30],
        [2, 2, 6, 2, 4, 6, 2, 2, 18, 4, 10],
        [1, 1, 3, 1, 2, 3, 3, 1, 3, 2, 5],
        [1, 1, 3, 3, 1, 3, 6, 4, 9, 1, 2],
        [6, 6, 18, 6, 6, 18, 6, 6, 54, 6, 6]
    ],
    [ // K = 10
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [4, 5, 4, 6, 20, 5, 12, 7, 12, 21, 20],
        [4, 4, 4, 4, 20, 4, 12, 4, 5, 20, 20],
        [2, 2, 2, 3, 10, 2, 6, 3, 6, 10, 10],
        [1, 1, 2, 2, 3, 2, 6, 4, 6, 3, 5],
        [1, 3, 1, 4, 5, 3, 2, 5, 3, 6, 10],
        [4, 4, 4, 4, 4, 4, 4, 4, 12, 4, 20],
        [4, 4, 4, 4, 20, 4, 4, 5, 4, 20, 20],
        [2, 2, 2, 2, 10, 2, 6, 2, 2, 10, 10],
        [1, 3, 1, 4, 3, 3, 6, 5, 1, 3, 2],
        [1, 2, 2, 2, 5, 2, 3, 4, 6, 10, 1]
    ],
    [ // K = 11
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [10, 10, 10, 11, 20, 10, 30, 12, 30, 20, 110],
        [5, 5, 5, 10, 20, 5, 30, 10, 6, 20, 5],
        [5, 5, 5, 5, 10, 5, 15, 6, 15, 10, 55],
        [5, 5, 10, 5, 5, 10, 30, 10, 30, 5, 55],
        [10, 10, 10, 11, 10, 10, 10, 12, 11, 10, 110],
        [10, 10, 10, 10, 20, 10, 10, 10, 30, 20, 110],
        [10, 10, 10, 10, 20, 10, 10, 10, 10, 20, 110],
        [5, 5, 5, 5, 10, 5, 15, 5, 5, 10, 5],
        [2, 2, 2, 3, 2, 2, 6, 4, 2, 2, 22],
        [1, 1, 2, 2, 1, 2, 3, 2, 6, 1, 3]
    ]
]

for (let i = 6; i <= 11; i++) {
    break;
    let valuesArr = []

    for (let j = 1; j <= 11; j++) {
        let baseArr = []
        for (k = 1; k <= 11; k++) {
            baseArr.push(cycleLength(k, j, i))
        }
        valuesArr.push(baseArr)
    }

    // console.log('\n',valuesArr[0],
    // '\n',valuesArr[1],
    // '\n',valuesArr[2],
    // '\n',valuesArr[3],
    // '\n',valuesArr[4],
    // '\n',valuesArr[5],
    // '\n',valuesArr[6],
    // '\n',valuesArr[7],
    // '\n',valuesArr[8],
    // '\n',valuesArr[9],
    // '\n',valuesArr[10])
    // console.log(valuesArr)
}


function cycleLength(base, divisor, k) {
    
    let mod = k * divisor
    let reducedBase = base % mod

    // console.log(mod)

    // if (reducedBase === 0 || reducedBase === 1) return 1;
    if (reducedBase === 0 || reducedBase === 1) return 0;

    // CYCLING
    let cycle = false, valuesArr = [];
    for (let i = 1, currVal = 1; i < 1000 && !cycle; i++) {
        valuesArr.push(currVal)
        currVal *= reducedBase
        currVal %= mod
        if (currVal === valuesArr[valuesArr.length - 1] && valuesArr.length > 2) {
            cycle = "CONTINUOUS"
            if (currVal === 0) valuesArr.shift()
        } else if (valuesArr.includes(currVal)) {
            cycle = true;
            if (currVal !== 1) valuesArr.shift()
        };
    };
    return valuesArr.length
};

function cycle(base, exponent, divisor, k, log) {
    
    let mod = k * divisor
    let reducedBase = base % mod
    let valuesMap = new Map([[0, 1]])

    // CYCLING
    let cycle = 0, valuesArr = [], initExp
    for (let i = 1, currVal = 1; i < 1000 && !cycle; i++) {
        valuesArr.push(currVal)
        currVal *= reducedBase
        currVal %= mod
        valuesMap.set(i, currVal)
        if (currVal === valuesArr[valuesArr.length - 1] && valuesArr.length > 2) {
            cycle = 'CONTINUOUS'
            if (currVal === 0) valuesArr.shift()
        } else if (valuesArr.includes(currVal)) {
            for (let i = valuesArr.length - 1; i >= 0; i--) {
                cycle++;
                if (valuesArr[i] === currVal) {
                    initExp = i
                    break;
                }
            }
            if (currVal !== 1) valuesArr.shift()
        };
    };
    
    if (log) console.log(cycle)
    if (log) console.log(exponent)
    if (log) console.log(initExp)
    
    let finalExponent = exponent

    if (cycle !== 'CONTINUOUS') {
        finalExponent -= initExp
        finalExponent %= cycle
        finalExponent = initExp + finalExponent
    }
    
    let ans;
    if (valuesMap.get(exponent)) {
        ans = valuesMap.get(exponent)
    } else {
        ans = valuesMap.get(finalExponent)
    }

    if (cycle === 'CONTINUOUS') {
        if (exponent >= valuesArr.length) ans = valuesArr[valuesArr.length - 1]
    }
    let cycleAnswer = ans + '/' + divisor

    // SQUARING

    // EXPAND EXPONENT
                
    let maxExponent = 0, binaryArr = []
    while (2 ** (maxExponent + 1) <= exponent) maxExponent++
    for (let i = maxExponent, currVal = exponent; i >= 0; i--) {
        if (exponent === 0) {
            break;
        }
        if (currVal - 2 ** i >= 0) {
            currVal -= 2 ** i
            binaryArr.push((2 ** i).toString())
        }
    };

    // CYCLING
    let squareValues = new Map([[undefined, 1]]);
    for (let i = 0, currVal = base; i < maxExponent + 1; i++) {
        if (i) {
            currVal **= 2
            currVal %= mod
        } else {
            currVal %= mod
        }
        squareValues.set((2 ** i).toString(), currVal)
    }

    // MULTIPLYING

    // console.log(binaryArr)
    // console.log(squareValues)

    let squareAnswer
    if (binaryArr.length > 1) {
        let product;
        for (let x of binaryArr) {
            if (product !== undefined) {
                product *= squareValues.get(x)
            } else {
                product = squareValues.get(x)
            };
        };

        squareAnswer = product % mod
    } else {
        squareAnswer = squareValues.get(binaryArr[0])
    }
    squareAnswer = squareAnswer + '/' + divisor
    
    if (log) console.log(cycleAnswer)
    if (log) console.log(squareAnswer)
    return (cycleAnswer === squareAnswer)
};

for (let i = 6; i <= 11; i++) {
    break;
    let valuesArr = []

    for (let j = 1; j <= 11; j++) {
        let baseArr = []
        for (k = 1; k <= 11; k++) {
            let truefalse = true
            for (let l = 0; l < 1; l++) {
                if (!cycle(k, l, j, i)) baseArr.push([k, l, j, i])
            }
        }
        if (!baseArr.length) continue
        valuesArr.push(baseArr)
    }

    // console.log('\n',valuesArr[0],
    // '\n',valuesArr[1],
    // '\n',valuesArr[2],
    // '\n',valuesArr[3],
    // '\n',valuesArr[4],
    // '\n',valuesArr[5],
    // '\n',valuesArr[6],
    // '\n',valuesArr[7],
    // '\n',valuesArr[8],
    // '\n',valuesArr[9],
    // '\n',valuesArr[10])
    // console.log(valuesArr)
}